---
title: 'GENUS Training Notes'
date: 2022-08-20
permalink: /posts/2022/08/blog-post-4/
tags:
  - ASIC Design
  - PnR
  - Synthesis
---

> The following is my notes of GENUS training course on Cadence’s training module

Module 03: genus fundamentals:
==============================
## common UI vs legacy mode
* unified commands with Tempus
* common us: `set_db` & `get_db`
* legacy mode: `set_attribute` & `get_attribute`
  - > `.synth_init` file: setup info, auto load when start legacy UI, can be skipped with `-no_custom` command line option

## explore design hier in legacy UI
* virtual directory structure
     * - `/:` root dir
         - designs
              - top_module
                  - instances_hier: current module’s hier instances
                  - instances_seq: current module’s sequential instances 
                  - instances_cmb: current module’s combinational instancs
         - libraries
         - hdl_libraries
         - flows
* use `find` to locate objects
  - ex. find all the pins `find /designs/* -pin *`

* use `ls` + `cd` to navigate through this virtual directory structure
  - even `rm`, `mv`, `pushd`, `popd`
  - report all related attributes associated for all the pins: `ls -la [find /designs/* -pin *]`
* navigate UNIX disk
  - `lpwd`, `lcd`, `lls`
 
 ## attributes 
 * `set_attribute <attr_name> <value> <object>`
 * `get_attribute <attr_name> <object>`
  * - works on single object only
* get help
  * - `get_attribute -h <attr_name> [<object_type>]`
      - get help on attribute
      - `<attr_name>` can include wildcards
  * `set_attribute -h`: reports writable attr      
* attr are dependent on the stage of synthesis flow
 ## input and output
 * input:  
    > RTL + constraint + library + power intent + physical
 * output: 
    > netlist + LEC dofile + ATPG, scanDEF + constraints + physical design input files 
 ## template script 
 * `write_template`
 ## flow
 1. setup libraries
  * `set_attribute init_lib_search_path <path> /`
  * ` set_attribute library $ls_lib`
  *  library domain for low-power design (if not included in CPF)
      - `create_library_domain {lib_domain1 lib_domain2}`
      - `set_attribute library $ls_lib1 lib_domain1 power_domain1`
  *  dont use
      - `set_attribute avoid <1/0> <cell_names>`
      - or use `set_dont_use <cell_names>`
  * (optional) setup physical layout estimation (PLE)
      - dynamically calculates wire delays for different logic structures 
      - vs Genus-Physical
          - floorplan DEF is optional
      - `set_attribute lef_library <lef_header>`
      - `set_attribute qrc_tech_file <qrc_tech_file_path>`
      - `set_attribute interconnect_mode ple`
 2. read HDL
  * `set_attr init_hdl_search_path <path> /`
  * `read_hdl`
 3. elaborate
  * what
      - build data structure, infer registers
      - high-level HDL opt, remove dead code
      - identify clock gating candidates
      - overwrite parameters for diff modules
  * `elaborate`
      - after elaboration, the `/designs` is populated
  * `check_design -all`
      - must: unresolved references 
 4. read constraints
  * `read_sdc` (preferred)
  * `echo $::dc::sdc_failed_commands > failed.sdc`
  * `check_timing_intent -verbose`
      - check failed commands and errors
 5. opt directives
  * preserve instances and subdesign (dont touch)
    - `set_attr` preserve <option> (more options than `set_dont_touch`)
         - false/true
         - delete_ok
         - const_prop_delete_ok
         - const_prop_size_delete_ok
         - size_ok
         - map_size_ok
         - size_delete_ok
  * grouping/ungrouping hierarchy
    - `group -group_name <name> <ls_inst>`
    - `ungroup <hier>`
    - disable ungrouping by `set_attr ungroup_ok false <inst>`
  * boundary opt (default performed)
    - disable by `set_attr boundary_opto false <sub_design>`
    - use dynamic hierarchical check to verify boundary opt in conformal LEC
  * opt sequential logic (default performed)
    - remove unused flops that is not driving an output port
    - disable by
        - `set_attr hdl_preserve_unused_register true /`
        - `set_attr delete_unloaded_seqs false /`
        - `set_attr optimize_constant_0_flops false /`
        - `set_attr optimize_constant_1_flops false /`
    - same thing to combinational logic that drives unloaded hier pins
        - disable by `set_attr prune_unused_logic false <pins>`
  * merge sequential logic (default performed)
    - combine flops and latches that are equivalent in the same hierarchy
    - disable by
        - `set_attr optimize_merge_flops false /`
        - `set_attr optimize_merge_latches false /`
        - `set_attr optimize_merge_seq false <inst>`
  * multibit cell inference (MBCI)
    - flops/tri-state cell/MUX/inverters/…
    - share clock to reduce power/improve reliability
    - LEC support
    - can control naming style (for verification)
    - `set_attr use_multibit_cells true`
  * other opt
    - opt async reset logic
        - `set_attr time_recovery_arcs true /`
    - auto ungrouping
        - `set_attr auto_ungroup {none | both}`
    - keep the synchronous feedback logic immediately in front of the sequential elements (?)
        - `set_attr hdl_ff_keep_feedback`
        - affect how enable logic of a flop is implemented
    - opt TNS other than WNS
        - `set_attr tns_opto true /`
 6. synthesis
  * 1st level: `syn_generic <-physical>`
    - tech independent RTL opt
        - can skip for netlist-to-netlist synthesis
    - `set_attr syn_generic_effort`
        - medium by default
  * 2nd level: `syn_map <-physical>`
    - mapping to lib, and logic op
        - initial structuring
            - constant propagation, clock gating
            - structuring for best delay
        - target info
            - estimate timing
        - global mapping
            - mapping to meet target
        - global incremental
            - net/drive opt
            - timing tuning
    - `set_attr syn_map_effort`
        - high by default
    - check the slack, if too negative, check the constraint/design
  * 3rd level: `syn_opt <-physical> <-spatial> <-incr>`
    - opt gates
          - fix drc, cleanup area, cleanup timing
    - `set_attr syn_opt_effort`
          - high by default
  * global effort
    - `set_attr syn_global_effort`
    - set to express while explore flow
        - accept not clean design
 7. analyze and report
  * after elaboration
    -  `check_design unresolved`
  * constraint
    -  `check_timing_intent`
    -  use Conformal Constraint Designer (CCD) tool to validate timing constraint
        - `write_to_ccd validate -sdc > dofile` generate dofile used in CCD
  * check `preserve` attributes, remove those that are not needed
  * ungrouping small blocks can improve timing/area
  * reports
    - report_area
    - report_dp (datapath)
    - report_design_rules (drc)
    - report_messages
    - report_power
    - report_qor
    - report_timing
    - report_summary
  * from GUI
    - > timing -> timing lint: gives a thorough
 8. gen outputs
  * `write_hdl > filename`
  * `write_sdc > filename`
  * `write_design -innovus`
 
# command help
  * `setenv MANPATH $CDN_SYNTH_ROOT/share/synth/man` to view man pages from UNIX shell
Module 04: datapath:
====================
# datapath info in virtual file system
  * /hdl_libraries/
    - /hdl_libraries/CW (chipware)
    - /hdl_libraries/DW (designware)
# datapath operation
 * architecture selection
 * sharing and speculation (unsharing)
 * carry-save arithmetic (CSA)
 * …
# datapath directives
 * CSA
    - `set_attr dp_csa {inherited|basic|none} <design>`
 * sharing and speculation
    - sharing: improve area
    - `set_attr dp_sharing`
    - `set_attr dp_speculation`
 * arch selection
    - manually control datapath arch selection (not recommended)
         - `set_attr user_speed_grade [find /designs* -subdesign <name>]` while speed can be ver_fast|fast|medium|slow|very_slow
 * reordering (reorder input to opt critical path)
 * ChipWare (CW)
    - also maps DesignWare components in RTL to CW
# opt in syn_generic
  * constant propagation
  * resource sharing
  * logic speculation
  * MUX opt
  * CSA opt
  * datapath rewritin
      - QoR driven RTL code rewrite
      - by default during `syn_generic` with high effort level
      - no LEC impact
      - ex.
``````````````````
assign p = a - b;
assign q = a + b;
assign y = s ? p : q;

# better timing, smaller area
assign t = {16{s}} ^ b;
assign y = a + t + s;
``````````````````
# report
  * `set_attr hdl_track_filename_row_col true` / `before read_hdl`
  * `report_dp` after every stages: elaboration/syn_gen/syn_map/syn_opt to track datapath components changes

Module 05: debug design scenarios:
==================================
# clipper flow
  * block level physical synthesis <-> unit level physical synthesis
    - unit level cannot understand block level’s congestion and physical context issues
    - so pass timing/physical context DEF and constraint from block level to unit level
  * CMD
    - `create_clip` at higher level
        - block boundary must be preserved (remember, genus is very aggressive about optimizing)
    - `read_clip` at lower level  
  
